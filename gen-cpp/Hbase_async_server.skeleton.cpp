// This autogenerated skeleton file illustrates one way to adapt a synchronous
// interface into an asynchronous interface. You should copy it to another
// filename to avoid overwriting it and rewrite as asynchronous any functions
// that would otherwise introduce unwanted latency.

#include "Hbase.h"
#include <protocol/TBinaryProtocol.h>
#include <async/TEventServer.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::async;

using boost::shared_ptr;

using namespace apache::hadoop::hbase::thrift;

class HbaseAsyncHandler : public HbaseCobSvIf {
 public:
  HbaseAsyncHandler() {
    syncHandler_ = std::auto_ptr<HbaseHandler>(new HbaseHandler);
    // Your initialization goes here
  }
  virtual ~HbaseAsyncHandler();

  void enableTable(std::tr1::function<void()> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Bytes& tableName) {
    syncHandler_->enableTable(tableName);
    return cob();
  }

  void disableTable(std::tr1::function<void()> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Bytes& tableName) {
    syncHandler_->disableTable(tableName);
    return cob();
  }

  void isTableEnabled(std::tr1::function<void(bool const& _return)> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Bytes& tableName) {
    bool _return = false;
    _return = syncHandler_->isTableEnabled(tableName);
    return cob(_return);
  }

  void compact(std::tr1::function<void()> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Bytes& tableNameOrRegionName) {
    syncHandler_->compact(tableNameOrRegionName);
    return cob();
  }

  void majorCompact(std::tr1::function<void()> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Bytes& tableNameOrRegionName) {
    syncHandler_->majorCompact(tableNameOrRegionName);
    return cob();
  }

  void getTableNames(std::tr1::function<void(std::vector<Text>  const& _return)> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */) {
    std::vector<Text>  _return;
    syncHandler_->getTableNames(_return);
    return cob(_return);
  }

  void getColumnDescriptors(std::tr1::function<void(std::map<Text, ColumnDescriptor>  const& _return)> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName) {
    std::map<Text, ColumnDescriptor>  _return;
    syncHandler_->getColumnDescriptors(_return, tableName);
    return cob(_return);
  }

  void getTableRegions(std::tr1::function<void(std::vector<TRegionInfo>  const& _return)> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName) {
    std::vector<TRegionInfo>  _return;
    syncHandler_->getTableRegions(_return, tableName);
    return cob(_return);
  }

  void createTable(std::tr1::function<void()> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const std::vector<ColumnDescriptor> & columnFamilies) {
    syncHandler_->createTable(tableName, columnFamilies);
    return cob();
  }

  void deleteTable(std::tr1::function<void()> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName) {
    syncHandler_->deleteTable(tableName);
    return cob();
  }

  void get(std::tr1::function<void(std::vector<TCell>  const& _return)> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const Text& row, const Text& column) {
    std::vector<TCell>  _return;
    syncHandler_->get(_return, tableName, row, column);
    return cob(_return);
  }

  void getVer(std::tr1::function<void(std::vector<TCell>  const& _return)> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const Text& row, const Text& column, const int32_t numVersions) {
    std::vector<TCell>  _return;
    syncHandler_->getVer(_return, tableName, row, column, numVersions);
    return cob(_return);
  }

  void getVerTs(std::tr1::function<void(std::vector<TCell>  const& _return)> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const int32_t numVersions) {
    std::vector<TCell>  _return;
    syncHandler_->getVerTs(_return, tableName, row, column, timestamp, numVersions);
    return cob(_return);
  }

  void getRow(std::tr1::function<void(std::vector<TRowResult>  const& _return)> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const Text& row) {
    std::vector<TRowResult>  _return;
    syncHandler_->getRow(_return, tableName, row);
    return cob(_return);
  }

  void getRowWithColumns(std::tr1::function<void(std::vector<TRowResult>  const& _return)> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const Text& row, const std::vector<Text> & columns) {
    std::vector<TRowResult>  _return;
    syncHandler_->getRowWithColumns(_return, tableName, row, columns);
    return cob(_return);
  }

  void getRowTs(std::tr1::function<void(std::vector<TRowResult>  const& _return)> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const Text& row, const int64_t timestamp) {
    std::vector<TRowResult>  _return;
    syncHandler_->getRowTs(_return, tableName, row, timestamp);
    return cob(_return);
  }

  void getRowWithColumnsTs(std::tr1::function<void(std::vector<TRowResult>  const& _return)> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const Text& row, const std::vector<Text> & columns, const int64_t timestamp) {
    std::vector<TRowResult>  _return;
    syncHandler_->getRowWithColumnsTs(_return, tableName, row, columns, timestamp);
    return cob(_return);
  }

  void getRows(std::tr1::function<void(std::vector<TRowResult>  const& _return)> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const std::vector<Text> & rows) {
    std::vector<TRowResult>  _return;
    syncHandler_->getRows(_return, tableName, rows);
    return cob(_return);
  }

  void getRowsWithColumns(std::tr1::function<void(std::vector<TRowResult>  const& _return)> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns) {
    std::vector<TRowResult>  _return;
    syncHandler_->getRowsWithColumns(_return, tableName, rows, columns);
    return cob(_return);
  }

  void getRowsTs(std::tr1::function<void(std::vector<TRowResult>  const& _return)> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const std::vector<Text> & rows, const int64_t timestamp) {
    std::vector<TRowResult>  _return;
    syncHandler_->getRowsTs(_return, tableName, rows, timestamp);
    return cob(_return);
  }

  void getRowsWithColumnsTs(std::tr1::function<void(std::vector<TRowResult>  const& _return)> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const int64_t timestamp) {
    std::vector<TRowResult>  _return;
    syncHandler_->getRowsWithColumnsTs(_return, tableName, rows, columns, timestamp);
    return cob(_return);
  }

  void mutateRow(std::tr1::function<void()> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const Text& row, const std::vector<Mutation> & mutations) {
    syncHandler_->mutateRow(tableName, row, mutations);
    return cob();
  }

  void mutateRowTs(std::tr1::function<void()> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const int64_t timestamp) {
    syncHandler_->mutateRowTs(tableName, row, mutations, timestamp);
    return cob();
  }

  void mutateRows(std::tr1::function<void()> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const std::vector<BatchMutation> & rowBatches) {
    syncHandler_->mutateRows(tableName, rowBatches);
    return cob();
  }

  void mutateRowsTs(std::tr1::function<void()> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const std::vector<BatchMutation> & rowBatches, const int64_t timestamp) {
    syncHandler_->mutateRowsTs(tableName, rowBatches, timestamp);
    return cob();
  }

  void atomicIncrement(std::tr1::function<void(int64_t const& _return)> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const Text& row, const Text& column, const int64_t value) {
    int64_t _return = 0;
    _return = syncHandler_->atomicIncrement(tableName, row, column, value);
    return cob(_return);
  }

  void deleteAll(std::tr1::function<void()> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const Text& row, const Text& column) {
    syncHandler_->deleteAll(tableName, row, column);
    return cob();
  }

  void deleteAllTs(std::tr1::function<void()> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const Text& row, const Text& column, const int64_t timestamp) {
    syncHandler_->deleteAllTs(tableName, row, column, timestamp);
    return cob();
  }

  void deleteAllRow(std::tr1::function<void()> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const Text& row) {
    syncHandler_->deleteAllRow(tableName, row);
    return cob();
  }

  void deleteAllRowTs(std::tr1::function<void()> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const Text& row, const int64_t timestamp) {
    syncHandler_->deleteAllRowTs(tableName, row, timestamp);
    return cob();
  }

  void scannerOpen(std::tr1::function<void(ScannerID const& _return)> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const Text& startRow, const std::vector<Text> & columns) {
    ScannerID _return = 0;
    _return = syncHandler_->scannerOpen(tableName, startRow, columns);
    return cob(_return);
  }

  void scannerOpenWithStop(std::tr1::function<void(ScannerID const& _return)> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns) {
    ScannerID _return = 0;
    _return = syncHandler_->scannerOpenWithStop(tableName, startRow, stopRow, columns);
    return cob(_return);
  }

  void scannerOpenWithPrefix(std::tr1::function<void(ScannerID const& _return)> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const Text& startAndPrefix, const std::vector<Text> & columns) {
    ScannerID _return = 0;
    _return = syncHandler_->scannerOpenWithPrefix(tableName, startAndPrefix, columns);
    return cob(_return);
  }

  void scannerOpenTs(std::tr1::function<void(ScannerID const& _return)> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const int64_t timestamp) {
    ScannerID _return = 0;
    _return = syncHandler_->scannerOpenTs(tableName, startRow, columns, timestamp);
    return cob(_return);
  }

  void scannerOpenWithStopTs(std::tr1::function<void(ScannerID const& _return)> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const int64_t timestamp) {
    ScannerID _return = 0;
    _return = syncHandler_->scannerOpenWithStopTs(tableName, startRow, stopRow, columns, timestamp);
    return cob(_return);
  }

  void scannerGet(std::tr1::function<void(std::vector<TRowResult>  const& _return)> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const ScannerID id) {
    std::vector<TRowResult>  _return;
    syncHandler_->scannerGet(_return, id);
    return cob(_return);
  }

  void scannerGetList(std::tr1::function<void(std::vector<TRowResult>  const& _return)> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const ScannerID id, const int32_t nbRows) {
    std::vector<TRowResult>  _return;
    syncHandler_->scannerGetList(_return, id, nbRows);
    return cob(_return);
  }

  void scannerClose(std::tr1::function<void()> cob, std::tr1::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const ScannerID id) {
    syncHandler_->scannerClose(id);
    return cob();
  }

 protected:
  std::auto_ptr<HbaseHandler> syncHandler_;
};

